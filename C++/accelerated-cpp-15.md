# Chapter 15
5.8/155p 문자 그림은
1. 새로운 문자 그림을 만들 때마다 문자를 복사해야 한다.
2. 문자 그림이 어떻게 형성되었는지 알 수 없다. 예를 들어 어떤 부분이 테두리고 아닌지 알 수 없다.
상속과 제네릭 핸들 클래스를 사용해 개선한다.

## 15.1
위 문제점들의 해결책
1. (구현상의 문제) 같은 데이터의 복사본을 더 적게 저장하여 해결: 14장 `Ptr` 클래스를 사용
2. (설계상의 문제) 문자 그림이 어떻게 만들어졌는지 구조 정보를 유지해 해결

#### 상속을 사용한 구조 모델링
- 공통 속성을 모델링한 기본 클래스 `Pic_base`를 정의하고, 4종류의 문자 그림 클래스 `String_Pic`, `Frame_Pic`, `Vcat_Pic`, `HCat_Pic`을 파생시킴
- 문자 그림 인터페이스 클래스 `Picture`를 정의하고, 프로그래머에게 상속 구조를 공개하지 않음

#### frame(), hcat(), vcat()
- `Picture` 객체의 상태를 바꾸지 않으므로 `Picture`의 멤버 함수로 구현할 이유가 없다.
- 다른 타입에서의 변환에서 사용하기 위해 (ex. `vector<string>` => `Picture`) `Picture`의 멤버 함수로 두지 않는다.
- 결합을 이용해 복잡한 문자 그림을 만들 때 인수들의 대칭성을 나타내기 위해 멤버 함수로 정의하지 않는다. (ex. `hcat(frame(p), p)` vs. `p.frame().hcat(p)`

#### 순수 가상 함수 (pure virtual function)와  추상 기본 클래스(abstract base class)
```cpp
class A {
  virtual void foo() = 0;
```

파생 클래스에서만 구현할 수 있는 가상 함수의 본문에 `= 0`을 넣어 정의문이 없음을 표시할 수 있다. 이는 해당 타입의 객체가 결코 존재하지 않음을 보장한다. 이러한 클래스는 상속 계층 구조에서 추상 인터페이스를 담는 추상 기본 클래스이다.  

파생 클래스가 상속받은 모든 순수 가상 함수를 정의한다면 해당 파생 클래스는 구상 클래스가 되며 객체를 만들 수 있다. 그러나 하나라도 정의하지 못한다면 추상 클래스로 남는다.

[TODO] 15.2.2
