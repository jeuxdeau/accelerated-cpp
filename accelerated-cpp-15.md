# Chapter 15
5.8/155p 문자 그림은
1. 새로운 문자 그림을 만들 때마다 문자를 복사해야 한다.
2. 문자 그림이 어떻게 형성되었는지 알 수 없다. 예를 들어 어떤 부분이 테두리고 아닌지 알 수 없다.
상속과 제네릭 핸들 클래스를 사용해 개선한다.

## 15.1
위 문제점들의 해결책
1. (구현상의 문제) 같은 데이터의 복사본을 더 적게 저장하여 해결: 14장 `Ptr` 클래스를 사용
2. (설계상의 문제) 문자 그림이 어떻게 만들어졌는지 구조 정보를 유지해 해결

#### 상속을 사용한 구조 모델링
- 공통 속성을 모델링한 기본 클래스 `Pic_base`를 정의하고, 4종류의 문자 그림 클래스 `String_Pic`, `Frame_Pic`, `Vcat_Pic`, `HCat_Pic`을 파생시킴
- 문자 그림 인터페이스 클래스 `Picture`를 정의하고, 프로그래머에게 상속 구조를 공개하지 않음

#### frame(), hcat(), vcat()
- `Picture` 객체의 상태를 바꾸지 않으므로 `Picture`의 멤버 함수로 구현할 이유가 없다.
- 다른 타입에서의 변환에서 사용하기 위해 (ex. `vector<string>` => `Picture`) `Picture`의 멤버 함수로 두지 않는다.
- 결합을 이용해 복잡한 문자 그림을 만들 때 인수들의 대칭성을 나타내기 위해 멤버 함수로 정의하지 않는다. (ex. `hcat(frame(p), p)` vs. `p.frame().hcat(p)`

#### 순수 가상 함수 (pure virtual function)와  추상 기본 클래스(abstract base class)
```cpp
class A {
  virtual void foo() = 0;
```

파생 클래스에서만 구현할 수 있는 가상 함수의 본문에 `= 0`을 넣어 정의문이 없음을 표시할 수 있다. 이는 해당 타입의 객체가 결코 존재하지 않음을 보장한다. 이러한 클래스는 상속 계층 구조에서 추상 인터페이스를 담는 추상 기본 클래스이다.  

파생 클래스가 상속받은 모든 순수 가상 함수를 정의한다면 해당 파생 클래스는 구상 클래스가 되며 객체를 만들 수 있다. 그러나 하나라도 정의하지 못한다면 추상 클래스로 남는다.

## 15.2

#### 추상 기본 클래스의 멤버 함수
추상 기본 클래스에 데이터 멤버 및 (일반적인 혹은 `static`)멤버 함수를 정의할 수 있다. 파생 클래스는 기본 클래스의 모든 멤버 함수를 상속한다. 기본 클래스의 멤버 함수는 파생 클래스 객체 중 기본 클래스 부분에서 실행된다.

#### friend 선언문
```cpp
class Base {
  friend class Derived;
}

class Derived : public Base {
  Base b;
}
```

`Derived`의 멤버는 `Derived` 객체나 `Derived`에서 파생된 클래스의 객체가 포함하는 `Base` 영역의 `protected` 멤버에 접근할 수 있다. 하지만 독립적인 `Base` 객체의 `protected` 멤버에는 접근할 수 없다. (예를 들어 `class Dervied`의 `Base b`의 `protected` 멤버는 `Derived`의 일부가 아니기 때문에 접근할 수 없다.) 따라서 `Base` 클래스에 `friend class Derived`를 추가하였다.

만약 파생 클래스 객체가 기본 클래스 객체의 `protected` 멤버에 직접 접근할 수 있다면, 클래스의 설계자가 본래 의도한 멤버 보호 수준이 쉽게 무너지게 된다. 예를 들어, 어떤 객체의 `protected` 멤버에 접근하고 싶을 때마다 해당 클래스를 상속하고 해당 멤버에 접근하는 함수를 정의하는 방식으로 악용할 수 있다.

## 15.3
#### 전방 선언문

이름의 정의는 이름을 사용하기 전에 해야 한다. 그런데 A 클래스가 B 클래스를 참조하고, B 클래스가 A 클래스를 참조 하는 것처럼 서로 참조 관계인 클래스의 집단을 만들 수도 있다. 이때는 이름만 선언할 수 있다.

```cpp
class A; // 이름일 뿐 클래스 자체를 표현하는 것은 아님
```

상호 타입 의존성을 이용해 실행할 수 없는 프로그램을 만들 수 있다.

```cpp
class A;

class B {
  A a;
};

class A {
  B b;
};
```

`A` 객체는 `A` 객체를 포함하는 `B` 객체를 포함한다. 이것을 구현하려면 무한한 메모리가 필요하다.

```cpp
class A;

class B {
  void foo(A& a);
};

class A {
  B* b_ptr;
};
```

위와 같은 경우는 문제가 되지 않는다. 먼저 `B::foo()`의 매개변수에 `A&`를 사용하였는데, 포인터(또는 참조)는 컴파일러가 해당 포인터를 이용해 함수를 호출하기 전까지는 실제로 포인터가 가리키는 타입의 세부 사항을 알 필요가 없다. 컴파일러는 `A`가 타입 이름이라는 것만 알면 된다.

`A::b_ptr`은 포인터이고 `B` 타입의 멤버가 직접 포함되지 않는다. 이처럼 포인터를 이용해 무한히 중첩한 객체 생성을 피할 수 있다.

