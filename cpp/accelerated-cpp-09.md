# Chapter 9

## 9.2

```cpp
double Student_info::grade() const {
  return ::grade(midterm, final, homework);
}
```

- 함수 선언에 사용한 `const`는 함수를 호출할 때 객체의 데이터 멤버를 바꾸지 않는다는 것을 뜻함.
  - `const` 객체를 다룰 때는 `const`가 아닌 함수를 호출할 수 없음
- `Student_info::grade`에서 범위 연산자 `::`는 표준 라이브러리가 정의한 이름에 접근하는 데 사용됨.
- `::grade()`에서 `::`는 멤버 함수가 아닌 함수를 사용한다는 의미임
- `Student_info&` 타입의 매개변수는 모든 호출에서 암묵적으로 존재

#### 멤버 함수

1. (생성자 함수처럼) 특정 종류의 함수들은 멤버로 정의해야 함.
2. 함수가 객체의 상태를 바꾼다면 해당 객체의 멤버가 되는 것이 자연스러움.

1, 2에 해당하지 않으면 멤버 함수로 정의할 수도 있고 아닐 수도 있다.

## 9.3

보호 레이블(protection label) 순서는 클래스 내부에서 임의로 바뀔 수 있고, 여러 번 등장할 수도 있다.

#### struct와 class

- struct나 class 모두 새로운 타입을 정의할 수 있다.
- struct와 class가 할 수 있는 일에는 차이가 없다. 클래스를 사용하는 프로그래머 입장에서도 struct와 class 중 무엇을 사용하고 있는지 알 수 없다.
- struct의 기본 보호 레이블은 public, class의 기본 보호 레이블은 private이다.
  - struct: 공개하려는 데이터 구조가 있는 간단한 타입
  - class: 멤버의 접근을 제어하는 타입

멤버 함수를 클래스 내부에 정의하면, 컴파일러는 상황에 따라 인라인으로 확장한다.

## 9.5

#### 데이터 멤버의 초기화

- 지역 변수: 기본 초기화. 임의의 의미 없는 값.
- 맵에 추가되는 새로운 요소, 크기가 지정된 컨테이너 요소: 값 초기화

```cpp
Student_info::Student_info(): midterm(0), final(0) {...}
```

#### 생성자 이니셜라이저

1. 객체를 담을 메모리가 할당됨
2. 이니셜라이저 목록에 있는 값으로 객체를 초기화함. 이때 순서는 클래스 정의에 명시된 순서와 같다.
3. 이니셜라이저 목록에 언급되지 않은 멤버도 초기화함.
4. 생성자 본문을 실행함

2번 특성 때문에 클래스 멤버를 사용하여 다른 멤버를 초기화할 때는 주의해야 한다. 이러한 상호 의존성을 피하기 위해서는 이니셜라이저가 아닌 본문에서 초기화한다.

### 연습문제

## 9.2

`compare()` 함수의 매개변수인 `const Student_info& x` 부분을 수정해야 한다.

## 9.7

```cpp
istream& Student_info::read(istream& in){
	in >> n >> midterm >> final;
	read_hw(in, homework);
	return in;
}
```
