# Chapter 10

## 10.1

#### 포인터

- 객체의 주소를 나타내는 값
- 포인터를 초기화하는 값은 0인데, 어떤 객체 포인터와도 중복되지 않기 때문이다.
- 주소 연산자 `&x` (참조 타입에서 쓰는 `&`와는 다름), 역참조 연산자 `*`, T 타입의 포인터 타입 `T*`

아래의 세 코드는 모두 같은 의미이다.

```cpp
/* 두 실행문은 같은 의미 */
int* p, q; // p만 포인터, q는 int 타입
int *p, q;
int (*p), q; // (*p)와 q는 같은 타입
```

#### 함수 포인터

- 함수를 인수로 사용할 때 컴파일러는 함수 호출을 함수 포인터를 사용하도록 변환한다.
- 함수 포인터를 역참조해서 할 수 있는 일은, (1) 해당 함수를 호출하거나 (2) 다시 함수의 주소를 얻는 것 뿐이다.
- 포인터를 명시적으로 역참조(`*`)하지 않아도 함수를 호출할 수 있다.
- 호출을 제외한 함수 사용에서는 `&`를 명시하지 않더라도 해당 함수의 주소를 얻는 것으로 간주한다.

```cpp
int next(int n) {
  return n + 1;
}

int (*fp)(int); // fp는 (int를 인수로 받아 int를 반환하는) 함수의 포인터

/* 두 실행문은 같은 의미 */
fp = &next;
fp = next;

/* 두 실행문은 같은 의미 */
i = (*fp)(i);
i = fp(i);
```

함수를 매개변수로 사용하면, 컴파일러는 해당 매개변수를 함수 포인터로 자동 변환한다.

```cpp
/* 두 실행문은 같은 의미 */
int foo(double bar(int));
int foo(double (*bar)(int));
```

함수를 반환 값으로 사용할 때는 반환 값이 함수 포인터임을 명시해야 한다. 자동 변환이 적용되지 않기 때문이다. 현실에서는 함수 포인터를 반환하는 함수는 거의 없다.

```cpp
// foo_fp라는 함수 포인터 타입 정의
typedef int (*foo_fp)(int);
foo_fp get_foo_ptr();

// 위와 같은 의미
int (*get_foo_ptr())(int);
```

#### 배열

- 배열의 개수는 컴파일 과정에서 결정된다. 동적으로 확장 또는 축소할 수 없다.
- 배열은 클래스가 아니므로 멤버가 없다. `size_type` 멤버도 없다. `<cstddef>` 헤더는 unsigned 타입 `size_t`를 정의한다.
- 배열 이름을 값으로 사용하면 해당 이름은 배열의 첫 번째 요소를 가리키는 포인터이다.

```cpp
// 예제: 물리적 공간에서 점으로 차원 나타내기
const size_t NDim = 3;
double coords[NDim];
*coords = 1.5;
```

#### 포인터

임의 접근 반복자

```cpp
// 초깃값을 할당하면 배열의 크기를 명시하지 않아도 된다.
const int numbers[] = { 1, 2, 3, 4, 5 };

// a가 x번째 요소를 가리키는 포인터라면, a[y] x + y번째 요소이다.
numbers[3];
*(numbers + 3);
```

- `p`와 `q`가 같은 배열의 포인터라면, `p - q`는 요소 사이의 거리이다.
  - `p - q`는 음수일 수 있으므로 부호가 있는 타입이다.
  - `<cstddef>` 헤더에 `ptrdiff_t` 타입이 정의되어 있다. `long`인지 `int`인지는 구현체에 따라 다르다.

## 10.2

#### 문자열 리터럴

리터럴의 문자 개수보다 요소가 하나 더 많은 `const char` 타입의 배열. 컴파일러가 마지막에 null 문자(`'\0'`)를 자동으로 추가하는데, 리터럴의 첫 주소만 알아도 끝이 어딘지를 알 수 있게 해준다.

```cpp
#include <string>
#include <cstring> // strlen()
const char bye[] = { 'B', 'y', 'e', '\0' };
string s(bye);
string s("Bye");
string s(bye, bye + strlen(bye));
```

## 10.3

#### const
```cpp
// 출처: https://boycoding.tistory.com/206
const int* ptr1 = &value; // ptr1 points to a "const int", so this is a pointer to a const value.
int* const ptr2 = &value; // ptr2 points to an "int", so this is a const pointer to a non-const value.
const int* const ptr3 = &value; // ptr3 points to a "const int", so this is a const pointer to a const value.
```

#### sizeof
`sizeof(e)`는 e 타입 객체가 차지하는 메모리의 크기를 `size_t` 타입으로 반환하는데, 단위는 바이트이다.

## 10.4
`main` 함수는 2개의 매개변수로 `int`와 `char**`를 가진다. 일반적으로 각각 `argc`와 `argv`로 부른다. (argument count and vector)

- `argc`는 `argv`가 가리키는 포인터 배열의 요소 개수이다.
- `argv` 값은 포인터 배열의 첫 번째 요소를 가리키는 포인터이다.
  - `argv`의 첫 번째 요소는 호출된 프로그램의 이름이다.
  - 두 번째 요소부터는 전달된 인수들이다.

> `char**`은 더블 포인터로 포인터를 가리키는 포인터이다.

## 10.5

#### 표준 오류 스트림
오류에 연결되는 출력 스트림. 버퍼링을 처리하는 방식에서 차이가 있다.

- `clog` 스트림: 기록용. 버퍼링 속성이 있다. 저장한 후 시스템이 적당하다고 생각하는 시점에 출력한다.
- `cerr` 스트림: 출력 결과를 언제나 즉시 출력한다.

#### 파일 입출력
파일 입출력에는 각각 `ifstream`, `ofstream` 타입의 객체를 사용한다. 두 타입은 `<fstream>`헤더에 정의되어 있다. 단 `ifstream`은 `istream`의 한 종류이고 `ofstream`은 `ostream`의 한 종류이다. 파일 이름은 문자열이 아닌 문자 배열의 첫 번째 요소를 가리키는 포인터를 사용해야 한다. 이유는 다음과 같다.

1. 문자열 기능을 사용하지 않고 입출력 라이브러리를 다룰 수 있는 선택권 제공
2. 입출력 라이브러리가 문자열 클래스보다 먼저 등장했기 때문
3. 운영체제의 입출력 기능이 포인터를 사용하기 때문에 상호작용이 편리함

파일 이름을 문자열로 사용하고 싶다면, 문자열에 파일 이름을 저장하고 멤버 함수인 `c_str()`을 사용해 변환한다.  

`ifstream` 객체를 조건으로 사용했을 때 결과가 거짓이라면, 파일이 존재하지 않거나 파일을 읽을 수 없는 이유가 있음을 의미한다.

## 10.6

#### new와 delete
`new T`는 기본 초기화된 `T` 타입의 객체를 할당한다. `new T(인수)`로 지정한 값으로 초기화할 수도 있다. 프로그램이 종료되거나, `delete p`를 실행할 때까지 메모리 할당을 유지한다. 이때 `p`는 `new`가 반환한 포인터의 복사본이다. `delete`는 `new`로 만들어진 포인터나 값이 0인 제로 포인터에만 사용할 수 있다.

#### new[]와 delete[]
`new T[n]`은 `T`타입의 객체 n개가 있는 배열을 할당하고 배열의 첫 번째 요소를 가리키는 `T*`타입 포인터를 반환한다.  

각 객체는 기본 초기화되는데, 즉
- `T`가 기본 타입이고 배열이 지역 범위 안에 할당될 때는 초기화가 일어나지 않는다.
- `T`가 클래스 타입이면 각 객체는 기본 생성자를 이용해 초기화된다.
- 클래스가 기본 초기화를 허용하지 않으면 컴파일되지 않는다.
- 배열의 n개 요소가 각각 초기화되는 오버헤드가 발생한다.

n이 0인 `new T[n]`을 실행해 요소를 갖지 않는 배열을 할당할 수 있다. 이때는 범위의 끝을 지난 지점을 가리키는 포인터로 사용한다. 해당 포인터를 `delete[]`할 수 있다.  

`delete[]`는 배열 전체의 메모리 할당을 해제한다. `new[]`로 메모리를 할당한 배열은 프로그램이 끝나거나 `delete[] p`를 실행하기 전까지 메모리가 유지된다. 이때 `p`는 `new[]`가 반환한 포인터의 복사본이다. `delete[]`는 각 요소를 역순으로 삭제한다.

## 나의 질문들
Q. 함수 포인터 리턴값은 함수 포인터로 자동 변환되지 않는다면, 어떤 일 발생?
